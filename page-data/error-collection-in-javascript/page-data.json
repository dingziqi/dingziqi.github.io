{"componentChunkName":"component---src-templates-blog-post-js","path":"/error-collection-in-javascript/","result":{"data":{"site":{"siteMetadata":{"title":"D.Z"}},"markdownRemark":{"id":"f055dbb9-11eb-51f7-8a41-8aa9ecd9c723","excerpt":"Error 对象 在 JavaScript 中，我们可以使用 Error 对象来描述程序出现的错误。它的原型对象是这样的： Error 对象还是一个构造器，我们可以用它来实例化一个错误实例。需要注意的是，我们实例化错误对象时是和创建普通的对象的操作是一样的，它并不会自动被错误处理函数捕获，我们需要通过 throw…","html":"<h2>Error 对象</h2>\n<p>在 JavaScript 中，我们可以使用 Error 对象来描述程序出现的错误。它的原型对象是这样的：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token class-name\">Error</span><span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">,</span> <span class=\"token comment\">// 错误名，默认情况为 Error</span>\n  message<span class=\"token punctuation\">,</span> <span class=\"token comment\">// 错误信息</span>\n  fileName<span class=\"token punctuation\">,</span> <span class=\"token comment\">// 调用 Error 构造器所在文件</span>\n  lineNumber<span class=\"token punctuation\">,</span> <span class=\"token comment\">// 调用 Error 构造器所在行数</span>\n  columnNumber<span class=\"token punctuation\">,</span> <span class=\"token comment\">// 调用 Error 构造器所在的列数</span>\n  stack<span class=\"token punctuation\">,</span> <span class=\"token comment\">// 用于描述调用 Error 构造器及向上的堆栈信息，每一条都会包含文件、行数及列数信息</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Error 对象还是一个构造器，我们可以用它来实例化一个错误实例。需要注意的是，我们实例化错误对象时是和创建普通的对象的操作是一样的，它并不会自动被错误处理函数捕获，我们需要通过 throw 操作或将它传递给错误处理函数。构造器的使用语法是: <code class=\"language-text\">new Error(message[, fileName[, lineNumber]])</code>。</p>\n<p>在 JavaScript 中会遇到很多种错误，为了在处理错误时能够更加方便的分辨错误的类型，我们可以直接使用预设的 Error 的子类。这些子类主要是在 <code class=\"language-text\">name</code> 属性有区别，如 <code class=\"language-text\">RangeError</code> 生成的实例的 <code class=\"language-text\">name</code> 属性都是 <code class=\"language-text\">RangeError</code>。其它的错误子类有：</p>\n<ul>\n<li><code class=\"language-text\">EvalError</code>：表明错误与 <code class=\"language-text\">eval</code> 有关</li>\n<li><code class=\"language-text\">InternalError</code>：表明错误与 JavaScript 引擎有，如“递归太多”</li>\n<li><code class=\"language-text\">RangeError</code>：表明错误信与数值信息或参数超出范围有关</li>\n<li><code class=\"language-text\">ReferenceError</code>：表明错误与错误引用有关</li>\n<li><code class=\"language-text\">SyntaxError</code>：表明错误是由 <code class=\"language-text\">eval()</code> 过程中遇到的语法错误导致</li>\n<li><code class=\"language-text\">TypeError</code>：表明错误是由变量或参数类型无效导致</li>\n<li><code class=\"language-text\">URIError</code>：表明错误是由 <code class=\"language-text\">encodeURI()</code> 或 <code class=\"language-text\">decodeURI()</code> 传递的 URI 无效导致</li>\n<li>…</li>\n</ul>\n<p>除了使用这些内置的 Error 子类，我们还可以自定义 Error 子类：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">CustomError</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Error</span> <span class=\"token punctuation\">{</span>\n  name <span class=\"token operator\">=</span> <span class=\"token string\">'customError'</span><span class=\"token punctuation\">;</span>\n\n  customProps <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>捕获错误的方式</h2>\n<p>我们最常见的捕获错误的方式是使用 <code class=\"language-text\">try-catch</code> 语法来包裹我们认为可能会出现错误的代码语句，需要注意的是，这种方式只能捕获到同步代码中抛出的错误，如果是异步操作中抛出的异常是无法捕获的，如：setTimeout 的回调函数中抛出异常，我们是无法在 setTimeout 这个语句外部的 <code class=\"language-text\">try-catch</code> 语句中捕获到错误的，只能在 setTimeout 的回调函数里去使用 <code class=\"language-text\">try-catch</code> 来捕获错误。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> err <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'something wrong'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">throw</span> err<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// do something with err</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>被抛出的异常如果没有在当前的 context 下被捕获的话会被传递到调用栈外层的 context，直至遇到 <code class=\"language-text\">try-catch</code> 语句或者栈顶为止。如果一直到栈顶都没有被 <code class=\"language-text\">try-catch</code> 捕获的话，我们还可以使用全局的错误捕获函数，如在 node 中是 <code class=\"language-text\">process.on('uncaughtException', errorHandler)</code>，在 browser 中是 <code class=\"language-text\">window.onerror = errorHandler/window.addEventListener('error', errorHandler)</code>。</p>\n<p>由于无法通过 <code class=\"language-text\">try-catch</code> 来捕获异步函数执行中抛出的异常，所以对于异步函数而言，通常会有另外特定的错误捕获方式。根据不同的异步函数与当前函数交互方式的区别，会有不同的捕获方式：</p>\n<ul>\n<li><code class=\"language-text\">异步 API</code>：在 node 中有提供很多异步 API，如 <code class=\"language-text\">fs.exists</code> 等等。 这些异步的 API 将错误传递给我们的回调函数的方式来让调用者处理错误。\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">fs<span class=\"token punctuation\">.</span><span class=\"token function\">exists</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./test.js'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> result</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// handle error in here</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n<li><code class=\"language-text\">promise</code>：Promise 构造器传入的函数是会立即执行的，但是里面同步部分的代码抛出的异常是无法被构造器外部的 <code class=\"language-text\">try-catch</code> 捕获的，至于里面的异步代码的话既不会被 promise 捕获也不会被外层的 <code class=\"language-text\">try-catch</code>。因为这部分的错误会被 Promise 自己 catch 调。我们可以通过 <code class=\"language-text\">.then()</code> 中的 <code class=\"language-text\">rejectedHandler</code> 或者是 <code class=\"language-text\">.catch()</code> 来捕获它。如果错误没有被正确的捕获的话，则向外冒泡到全局，在 node 中是通过 <code class=\"language-text\">process.on(unhandledrejection, handler)</code> 、在 browser 中是通过 <code class=\"language-text\">window.onunhandledrejection = handler/window.addEventListener('unhandledrejection', handler)</code> 来捕获。如果全局都没有被捕获的话，则会抛出相应的异常。</li>\n<li><code class=\"language-text\">async-await</code>：<code class=\"language-text\">async-await</code> 是 ES2017 引入的语法，async 函数的执行结果是一个 promise 对象，所以我们可以像处理普通的 promise 对象一样来捕获它的错误。而在它的内部，异步操作主要是在 await 操作符之后，而 await 操作符后的变量/函数都会被转换成一个 promise 对象，当中发生的错误会被转换成 rejected 的 promise，这些 rejected 的 promise 会阻塞 async 函数的继续执行，我们可以借助 <code class=\"language-text\">try-catch</code> 来捕获这些 await 操作抛出的 rejected 的 promise。</li>\n</ul>","frontmatter":{"title":"JavaScript中的错误收集","date":"06-24, 2021","description":null,"tags":"JavaScript"}},"previous":{"fields":{"slug":"/why-postmessage-execute-fail/"},"frontmatter":{"title":"postMessage execute fail 之谜"}},"next":{"fields":{"slug":"/remove-disqus-as/"},"frontmatter":{"title":"去除disqus广告"}}},"pageContext":{"id":"f055dbb9-11eb-51f7-8a41-8aa9ecd9c723","previousPostId":"301309ee-eb7e-5ae2-8402-702bbd6c220c","nextPostId":"c5d4dc48-eaf1-55fd-be4f-fb3e7165408b"}},"staticQueryHashes":["2841359383"]}