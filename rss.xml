<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[D.Z]]></title><description><![CDATA[个人博客]]></description><link>https://dingziqi.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Wed, 20 Oct 2021 06:47:48 GMT</lastBuildDate><item><title><![CDATA[记录排查上传大视频导致浏览器奔溃的问题]]></title><description><![CDATA[背景 负责达人后台的同事找我帮忙排查一个问题，说是在上传超过 1G 视频的时候浏览器会奔溃，浏览器提示的是内存不足，他们给我的初步判断是没有使用分片上传导致的。 排查过程 如何分片上传 因为上传一般都是用云服务商提供的 sdk…]]></description><link>https://dingziqi.github.io/fix-crash-when-upload-file/</link><guid isPermaLink="false">https://dingziqi.github.io/fix-crash-when-upload-file/</guid><pubDate>Wed, 20 Oct 2021 14:46:00 GMT</pubDate><content:encoded>&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;负责达人后台的同事找我帮忙排查一个问题，说是在上传超过 1G 视频的时候浏览器会奔溃，浏览器提示的是内存不足，他们给我的初步判断是没有使用分片上传导致的。&lt;/p&gt;
&lt;h2&gt;排查过程&lt;/h2&gt;
&lt;h3&gt;如何分片上传&lt;/h3&gt;
&lt;p&gt;因为上传一般都是用云服务商提供的 sdk，所以一般大家对如何分片上传其实都不太了解。&lt;/p&gt;
&lt;p&gt;其实文件的分片很简单，直接对 blob 对象做切割即可。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; chunks &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; chunkSize &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1024&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1024&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 1M&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; start &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;start &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; file&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;size&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; end &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; start &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; chunkSize
  chunks&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;file&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;slice&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;start&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; end&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  start &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; end
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上传的话直接构建 FormData 对象提交即可，利用分片我们还可以实现断点续传，秒传（同一文件直接返回服务器有资源）等。&lt;/p&gt;
&lt;h3&gt;何时会写入内存&lt;/h3&gt;
&lt;p&gt;Chrome 目前内置有一个标签/插件级别的任务管理器，通过这个任务管理器我们就可以看到每个标签或者插件对应的内存/CPU/网络的占用情况，这个新增的功能貌似已经有半年以上了。我们可以通过在浏览器头部的空白区域点击【右键/任务管理器】来打开它。&lt;/p&gt;
&lt;p&gt;有了这个工具，我们就可以观察我们的页面内存的变化情况，这样就能排查究竟是什么步骤占用了大量的内存。通过观察发现，内存暴增在点击 input 选择完文件后就已经发生了，所以可以确认并非是上传操作导致的。input 标签选择文件这个操作肯定不会直接把文件写入内存的，不然根本就不可能上传大文件了，所以应该还是在选择完文件后有后续的操作导致内存暴增。&lt;/p&gt;
&lt;p&gt;阅读源码后，发现在 input 的 change 回调里有一些的操作来读取视频的信息用于对上传做限制。具体做法是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;文件的大小&lt;/strong&gt;：
这个直接读取 event 对象下的 file 对象的 size 属性即可读到。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; size &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; file&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;size&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;视频的宽高&lt;/strong&gt;
视频宽度读取的操作有点迷，我解释不通…&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt;  reader &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;FileReader&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
reader&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;readAsDataURL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;file&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
reader&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;onload&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; videoObjUrl &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;URL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createObjectURL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;file&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; videoObj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;video&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

videoObj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;onloadmetadata&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token constant&quot;&gt;URL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;revokeObjectURL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;videoObjUrl&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// ... videoObj.videoHeight&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// ... videoObj.videoWidth&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

videoObj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;src &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; videoObjUrl&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
videoObj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;视频的时长&lt;/strong&gt;
时长是通过 Audio 接口获取的，具体步骤是通过 &lt;code class=&quot;language-text&quot;&gt;URL.createObjectURL&lt;/code&gt; 将 change 事件的 file 对象转换成可识别的 URL 供 Audio 来加载使用，然后监听实例化后的 audio 元素的 &lt;code class=&quot;language-text&quot;&gt;loadedmetadata&lt;/code&gt; 事件，这个事件会在获取到视频元数据后响应，而且此时是无需加载视频内容数据的。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; fileUrl &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;URL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createObjectURL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;file&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; audio &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Audio&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fileUrl&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
audio&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;loadedmetadata&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// audio.duration&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要了解上述一系列的操作，我们需要熟悉以下一些知识：&lt;/p&gt;
&lt;h4&gt;file 对象&lt;/h4&gt;
&lt;p&gt;我们通过监听 input 的 change 事件拿到的是一个 FileList 对象，每项是一个 File 对象。File 对象是一类特殊的 Blob 对象，所以会有一些关于文件的信息，如：&lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;、&lt;code class=&quot;language-text&quot;&gt;size&lt;/code&gt;、&lt;code class=&quot;language-text&quot;&gt;lastModified&lt;/code&gt; 等，这些都是只读属性。&lt;/p&gt;
&lt;h4&gt;ObjectURL / DataURL(s)&lt;/h4&gt;
&lt;p&gt;File 对象本身就是一个 Blob 对象，所以可以直接被 &lt;code class=&quot;language-text&quot;&gt;FileReader&lt;/code&gt;、&lt;code class=&quot;language-text&quot;&gt;XMLHttpRequest.send()&lt;/code&gt; 等 API 使用，但是如果 File 是图片或者视频时，我们还可能希望能被 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;audio&gt;&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;video&gt;&lt;/code&gt; 等元素使用（如上传时的预览）。但是这些元素都只支持通过 url 来访问资源，所以我们必须将要想办法将 blob 类型 file 转换成 url 才行。&lt;/p&gt;
&lt;p&gt;我们可以借助 JavaScript 将 blob 对象转换成两种类型的 url：&lt;/p&gt;
&lt;p&gt;一种是 ObjectURL/BlobURL，对应的是 &lt;code class=&quot;language-text&quot;&gt;URL.createObjectURL&lt;/code&gt; 方法，它是字符类型，格式是 &lt;code class=&quot;language-text&quot;&gt;blob:http://xxx.com/id&lt;/code&gt;。使用这种 URL 需要注意几点：ObjectURL 需要手动内存回收，通过 &lt;code class=&quot;language-text&quot;&gt;URL.revokeObjectURL(target)&lt;/code&gt; 来实现，另外就是每次都会创建新的 ObjectURL，即使是对同一个对象进行操作。&lt;/p&gt;
&lt;p&gt;另一种就是 DataURL，它也是字符类型，格式为 &lt;code class=&quot;language-text&quot;&gt;data:[mediatype][;base64],&amp;lt;data&gt;&lt;/code&gt;，我们是通过 &lt;code class=&quot;language-text&quot;&gt;FileReader.prototype.readAsDataURL&lt;/code&gt; 来将 File 对象转换成 DataURL 形式。&lt;/p&gt;
&lt;p&gt;上述两种 URL 的区别是 ObjectURL 只是对 Blob 对象的引用，而 DataURL 会把 Blob 对象转换成 base64 格式。了解这个之后，我们便能发现是在获取视频宽高时使用了 DataURL 导致内存占用上升。&lt;/p&gt;
&lt;h2&gt;解决方案&lt;/h2&gt;
&lt;p&gt;旧方案其实是漏洞百出，可以说是错误的解决方案，只是碰巧凑到一起把问题解决了。我们的目标是获取视频的信息，所以压根就不能用 audio 来加载 metadata，因为 audio 肯定只能获取单纯的音频信息。然后就是错误的使用了 DataURL，直接使用 ObjectURL 就能让 video 加载 metadata的，所以最终的方案会是如下：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; objUrl &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;URL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createObjectURL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;file&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; video &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;video&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
video&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;src &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; objUrl&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
video&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;loadmetadata&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// video.duration&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// video.videoHeight&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// video.videoWidth&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[去除disqus广告]]></title><description><![CDATA[今天打开网站发现在文章底部居然还有广告，我一个静态站应该也不会被人黑才对，审查元素后才发现居然是 Disqus 的广告…，并且还不能在 Disqus 后台关闭，这哪能忍，直接上代码： 终于又恢复了往日的整洁了！]]></description><link>https://dingziqi.github.io/remove-disqus-as/</link><guid isPermaLink="false">https://dingziqi.github.io/remove-disqus-as/</guid><pubDate>Thu, 30 Sep 2021 11:05:52 GMT</pubDate><content:encoded>&lt;p&gt;今天打开网站发现在文章底部居然还有广告，我一个静态站应该也不会被人黑才对，审查元素后才发现居然是 Disqus 的广告…，并且还不能在 Disqus 后台关闭，这哪能忍，直接上代码：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;css&quot;&gt;&lt;pre class=&quot;language-css&quot;&gt;&lt;code class=&quot;language-css&quot;&gt;&lt;span class=&quot;token selector&quot;&gt;iframe:not([src])&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; none&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;终于又恢复了往日的整洁了！&lt;/p&gt;</content:encoded></item><item><title><![CDATA[JavaScript中的错误收集]]></title><description><![CDATA[Error 对象 在 JavaScript 中，我们可以使用 Error 对象来描述程序出现的错误。它的原型对象是这样的： Error…]]></description><link>https://dingziqi.github.io/error-collection-in-javascript/</link><guid isPermaLink="false">https://dingziqi.github.io/error-collection-in-javascript/</guid><pubDate>Thu, 24 Jun 2021 16:28:00 GMT</pubDate><content:encoded>&lt;h2&gt;Error 对象&lt;/h2&gt;
&lt;p&gt;在 JavaScript 中，我们可以使用 Error 对象来描述程序出现的错误。它的原型对象是这样的：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token class-name&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  name&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 错误名，默认情况为 Error&lt;/span&gt;
  message&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 错误信息&lt;/span&gt;
  fileName&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 调用 Error 构造器所在文件&lt;/span&gt;
  lineNumber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 调用 Error 构造器所在行数&lt;/span&gt;
  columnNumber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 调用 Error 构造器所在的列数&lt;/span&gt;
  stack&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 用于描述调用 Error 构造器及向上的堆栈信息，每一条都会包含文件、行数及列数信息&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Error 对象还是一个构造器，我们可以用它来实例化一个错误实例。需要注意的是，我们实例化错误对象时是和创建普通的对象的操作是一样的，它并不会自动被错误处理函数捕获，我们需要通过 throw 操作或将它传递给错误处理函数。构造器的使用语法是: &lt;code class=&quot;language-text&quot;&gt;new Error(message[, fileName[, lineNumber]])&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在 JavaScript 中会遇到很多种错误，为了在处理错误时能够更加方便的分辨错误的类型，我们可以直接使用预设的 Error 的子类。这些子类主要是在 &lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt; 属性有区别，如 &lt;code class=&quot;language-text&quot;&gt;RangeError&lt;/code&gt; 生成的实例的 &lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt; 属性都是 &lt;code class=&quot;language-text&quot;&gt;RangeError&lt;/code&gt;。其它的错误子类有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;EvalError&lt;/code&gt;：表明错误与 &lt;code class=&quot;language-text&quot;&gt;eval&lt;/code&gt; 有关&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;InternalError&lt;/code&gt;：表明错误与 JavaScript 引擎有，如“递归太多”&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;RangeError&lt;/code&gt;：表明错误信与数值信息或参数超出范围有关&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;ReferenceError&lt;/code&gt;：表明错误与错误引用有关&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;SyntaxError&lt;/code&gt;：表明错误是由 &lt;code class=&quot;language-text&quot;&gt;eval()&lt;/code&gt; 过程中遇到的语法错误导致&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;TypeError&lt;/code&gt;：表明错误是由变量或参数类型无效导致&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;URIError&lt;/code&gt;：表明错误是由 &lt;code class=&quot;language-text&quot;&gt;encodeURI()&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;decodeURI()&lt;/code&gt; 传递的 URI 无效导致&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了使用这些内置的 Error 子类，我们还可以自定义 Error 子类：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CustomError&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;customError&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  customProps &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;捕获错误的方式&lt;/h2&gt;
&lt;p&gt;我们最常见的捕获错误的方式是使用 &lt;code class=&quot;language-text&quot;&gt;try-catch&lt;/code&gt; 语法来包裹我们认为可能会出现错误的代码语句，需要注意的是，这种方式只能捕获到同步代码中抛出的错误，如果是异步操作中抛出的异常是无法捕获的，如：setTimeout 的回调函数中抛出异常，我们是无法在 setTimeout 这个语句外部的 &lt;code class=&quot;language-text&quot;&gt;try-catch&lt;/code&gt; 语句中捕获到错误的，只能在 setTimeout 的回调函数里去使用 &lt;code class=&quot;language-text&quot;&gt;try-catch&lt;/code&gt; 来捕获错误。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; err &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;something wrong&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;throw&lt;/span&gt; err&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;err&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// do something with err&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;被抛出的异常如果没有在当前的 context 下被捕获的话会被传递到调用栈外层的 context，直至遇到 &lt;code class=&quot;language-text&quot;&gt;try-catch&lt;/code&gt; 语句或者栈顶为止。如果一直到栈顶都没有被 &lt;code class=&quot;language-text&quot;&gt;try-catch&lt;/code&gt; 捕获的话，我们还可以使用全局的错误捕获函数，如在 node 中是 &lt;code class=&quot;language-text&quot;&gt;process.on(&apos;uncaughtException&apos;, errorHandler)&lt;/code&gt;，在 browser 中是 &lt;code class=&quot;language-text&quot;&gt;window.onerror = errorHandler/window.addEventListener(&apos;error&apos;, errorHandler)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;由于无法通过 &lt;code class=&quot;language-text&quot;&gt;try-catch&lt;/code&gt; 来捕获异步函数执行中抛出的异常，所以对于异步函数而言，通常会有另外特定的错误捕获方式。根据不同的异步函数与当前函数交互方式的区别，会有不同的捕获方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;异步 API&lt;/code&gt;：在 node 中有提供很多异步 API，如 &lt;code class=&quot;language-text&quot;&gt;fs.exists&lt;/code&gt; 等等。 这些异步的 API 将错误传递给我们的回调函数的方式来让调用者处理错误。
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;fs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;exists&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;./test.js&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;err&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; result&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;err&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// handle error in here&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;promise&lt;/code&gt;：Promise 构造器传入的函数是会立即执行的，但是里面同步部分的代码抛出的异常是无法被构造器外部的 &lt;code class=&quot;language-text&quot;&gt;try-catch&lt;/code&gt; 捕获的，至于里面的异步代码的话既不会被 promise 捕获也不会被外层的 &lt;code class=&quot;language-text&quot;&gt;try-catch&lt;/code&gt;。因为这部分的错误会被 Promise 自己 catch 调。我们可以通过 &lt;code class=&quot;language-text&quot;&gt;.then()&lt;/code&gt; 中的 &lt;code class=&quot;language-text&quot;&gt;rejectedHandler&lt;/code&gt; 或者是 &lt;code class=&quot;language-text&quot;&gt;.catch()&lt;/code&gt; 来捕获它。如果错误没有被正确的捕获的话，则向外冒泡到全局，在 node 中是通过 &lt;code class=&quot;language-text&quot;&gt;process.on(unhandledrejection, handler)&lt;/code&gt; 、在 browser 中是通过 &lt;code class=&quot;language-text&quot;&gt;window.onunhandledrejection = handler/window.addEventListener(&apos;unhandledrejection&apos;, handler)&lt;/code&gt; 来捕获。如果全局都没有被捕获的话，则会抛出相应的异常。&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;async-await&lt;/code&gt;：&lt;code class=&quot;language-text&quot;&gt;async-await&lt;/code&gt; 是 ES2017 引入的语法，async 函数的执行结果是一个 promise 对象，所以我们可以像处理普通的 promise 对象一样来捕获它的错误。而在它的内部，异步操作主要是在 await 操作符之后，而 await 操作符后的变量/函数都会被转换成一个 promise 对象，当中发生的错误会被转换成 rejected 的 promise，这些 rejected 的 promise 会阻塞 async 函数的继续执行，我们可以借助 &lt;code class=&quot;language-text&quot;&gt;try-catch&lt;/code&gt; 来捕获这些 await 操作抛出的 rejected 的 promise。&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[postMessage execute fail 之谜]]></title><description><![CDATA[最近在使用了的项目中遇到了一个报错，报错的大致内容如下： 当时的html页面结构大致是这样： 从报错信息来看似乎是因为调用 postMessage 传入的 targetOrigin 和对应 iframe 实际的 url 不一致导致的，那这可能是 postMessage…]]></description><link>https://dingziqi.github.io/why-postmessage-execute-fail/</link><guid isPermaLink="false">https://dingziqi.github.io/why-postmessage-execute-fail/</guid><pubDate>Thu, 21 Nov 2019 15:39:44 GMT</pubDate><content:encoded>&lt;p&gt;最近在使用了&lt;code class=&quot;language-text&quot;&gt;postMessage&lt;/code&gt;的项目中遇到了一个报错，报错的大致内容如下：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(index):20 Failed to execute &apos;postMessage&apos; on &apos;DOMWindow&apos;:
The target origin provided (&apos;http://www.a.com&apos;) does not match the recipient
window&apos;s origin (&apos;http://www.b.com&apos;).&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当时的html页面结构大致是这样：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;html&quot;&gt;&lt;pre class=&quot;language-html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;html&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
  ...
  &lt;span class=&quot;token comment&quot;&gt;&amp;lt;!-- www.b.com --&gt;&lt;/span&gt;

  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;body&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;iframe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;iframe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;script&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token script&quot;&gt;&lt;span class=&quot;token language-javascript&quot;&gt;
      &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// 这里是在一个异步操作中&lt;/span&gt;
      iframe&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;src &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;http://www.a.com&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// 有多次 postMessage 操作&lt;/span&gt;
      iframe&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;contentWindow&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;postMessage&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;message&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;http://www.a.com&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;script&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;body&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;html&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从报错信息来看似乎是因为调用 postMessage 传入的 targetOrigin 和对应 iframe 实际的 url 不一致导致的，那这可能是 postMessage 对 targetOrigin 校验错误信息。但是我 postMessage 中设置的 targetOrigin 是和 iframe 的 url 是一模一样的。而且错误信息中提示我 recipient window 的origin 是 &lt;a href=&quot;http://www.b.com%EF%BC%8C%E6%88%91%E5%B9%B6%E6%B2%A1%E6%9C%89%E7%BB%99&quot;&gt;http://www.b.com，我并没有给&lt;/a&gt; iframe 设置过类似的 url。并且后续的 postMessage 操作又没有报这个错误了。&lt;/p&gt;
&lt;p&gt;经过我一番 debug 之后才发现，报错是发生在异步设置 iframe 的 src 之前，也就是说是当时的 iframe 的 src 并没有值。但是抛出的异常信息又说 recipient window 的 origin 的值是 b.com，简直是在误导我…&lt;/p&gt;
&lt;p&gt;并且，我 debug 的过程中我还发现了一个更毁三观的问题。当我试着把 iframe 的 src 改成 &lt;a href=&quot;http://www.baidu.com&quot;&gt;http://www.baidu.com&lt;/a&gt; （与 targetOrigin 不同时），竟然不会报上面那个错。WTF！那我前面的猜想&lt;code class=&quot;language-text&quot;&gt;那这可能是 postMessage 对 targetOrigin 校验错误信息&lt;/code&gt; 不就是错的了。&lt;/p&gt;
&lt;p&gt;我只好又写了几个 demo 来测试，最后发现只有在 iframe 的 src 没有值，或者它的值中的主机名与 targetOrigin 中的主机名一致，但是 origin 又不一致（即端口或者协议不同）的情况下才会抛出是上面那个错误。如： &lt;code class=&quot;language-text&quot;&gt;http://www.a.com&lt;/code&gt; 与 &lt;code class=&quot;language-text&quot;&gt;http://www.a.com:8080&lt;/code&gt; 才会报错。&lt;code class=&quot;language-text&quot;&gt;http://www.a.com&lt;/code&gt; 与 &lt;code class=&quot;language-text&quot;&gt;http://www.b.com&lt;/code&gt; 这样并不会报错，只是 message 不会被传递而已。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外讲一个写 demo 过程中发现的问题。&lt;/strong&gt; &lt;a href=&quot;https://codepen.io/&quot;&gt;https://codepen.io/&lt;/a&gt; 和 &lt;a href=&quot;https://jsbin.com/&quot;&gt;https://jsbin.com/&lt;/a&gt; 这两个在线编辑器中，如果我在 &lt;code class=&quot;language-text&quot;&gt;HTML&lt;/code&gt; tab 中有 iframe 标签的话，那我在 &lt;code class=&quot;language-text&quot;&gt;JavaScript&lt;/code&gt; tab 编写的内容会被添加我自己编写的 iframe 中…。这个 bug 也是醉人呐~&lt;/p&gt;</content:encoded></item><item><title><![CDATA[详解 webpack devtool 配置]]></title><description><![CDATA[什么是 sourceMap？ sourceMap 是一类用于描述文件压缩混淆前后内容映射的文件，它以 .map 为后缀名，内容为一个 JavaScript 对象。 sourceMap…]]></description><link>https://dingziqi.github.io/webpack-devtool-config/</link><guid isPermaLink="false">https://dingziqi.github.io/webpack-devtool-config/</guid><pubDate>Fri, 17 May 2019 19:41:52 GMT</pubDate><content:encoded>&lt;h1&gt;什么是 sourceMap？&lt;/h1&gt;
&lt;p&gt;sourceMap 是一类用于描述文件压缩混淆前后内容映射的文件，它以 .map 为后缀名，内容为一个 JavaScript 对象。&lt;/p&gt;
&lt;p&gt;sourceMap 的产生是由于现在前端开发过程中为了节省带宽，通常会对源码文件进行压缩和混淆，这就导致我们在浏览器中 debug 代码时面对的是压缩和混淆后的代码。所以浏览器提供了一项 souceMap 能力，通过 map 文件来描述压缩文件和原始文件间内容的映射，这样我们在 source 面板下可以对原始文件进行打点调试。&lt;/p&gt;
&lt;p&gt;souceMap 并不仅限于 js 文件，css 也支持 sourceMap。&lt;/p&gt;
&lt;h1&gt;webpack 中的 sourceMap&lt;/h1&gt;
&lt;p&gt;我们以 webpack@4 为例，我们可以通过 devTool 配置来控制如何生成 sourceMap。webpack 提供了很多种方式：source-map、cheap-source-map 等等。总的来说可以根据功能分类成以下几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;eval：源码以字符的形式被 eval(…) 来调用，不会生成 sourceMap 信息，只会通过一个 sourceURL 来存储原始文件的位置。&lt;/li&gt;
&lt;li&gt;source-map：会生成 sourceMap 信息，默认会输出到一个 .map 文件中，且源码中会通过 sourceMappingURL 来指定对应 map 文件位置。&lt;/li&gt;
&lt;li&gt;cheap：生成的 sourceMap 信息不包含列信息。&lt;/li&gt;
&lt;li&gt;module：生成的 sourceMap 信息还包含 loader 处理前后的映射信息，比如源码是 jsx，如果没有使用含 module 的 sourceMap，则只能解析回 js 形式，使用了含 module 的则可以解析回 jsx。&lt;/li&gt;
&lt;li&gt;inline: map 信息以 DataURI 的方式存放在源码文件中。
具体各种值的打包效果可以参见参考 1。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;踩坑&lt;/h1&gt;
&lt;p&gt;使用了 react-hot-loader 需要使用 cheap-module-eval-source-map sourceMap 的行号映射才正确。&lt;/p&gt;
&lt;p&gt;#参考&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;webpack 支持的各种 sourceMap 类型&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[JavaScript代码检查及与gulp、git的结合使用]]></title><description><![CDATA[在团队开发过程中，我们可能会要浪费一些时间在代码检查上，譬如拼写的检查、代码规范的检查。作为码农，我们当然不能把自己的时间浪费这种无意义的事情上，所以本篇我将介绍一些自动化代码检查的东西和项目实际上的应用。 JSHint 安装及使用 JSHint是一个用于 JavaScript…]]></description><link>https://dingziqi.github.io/code-check-with-git/</link><guid isPermaLink="false">https://dingziqi.github.io/code-check-with-git/</guid><pubDate>Sat, 16 Jul 2016 14:55:14 GMT</pubDate><content:encoded>&lt;p&gt;在团队开发过程中，我们可能会要浪费一些时间在代码检查上，譬如拼写的检查、代码规范的检查。作为码农，我们当然不能把自己的时间浪费这种无意义的事情上，所以本篇我将介绍一些自动化代码检查的东西和项目实际上的应用。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3&gt;JSHint&lt;/h3&gt;
&lt;h4&gt;安装及使用&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;http://jshint.com/&quot;&gt;JSHint&lt;/a&gt;是一个用于 JavaScript 代码静态检查的一些开源项目。他是运行与 node 环境，可以对我们指定的 JavaScript 文件进行一些静态的语法分析，譬如：变量定义、拼写检查、代码风格的检查等，而且检查项是灵活可配置的，可以针对不同项目的要求配置相应的检查项。JSHint 使用方式有多种，他可以通过命令行、node_module、集成到 IDE 这些方式来执行。在 IDE 中主要是通过插件的形式来使用，大家在自己顺手的 IDE 上搜&lt;code class=&quot;language-text&quot;&gt;JSHint&lt;/code&gt;的插件来使用，接下来我主要讲一下在命令行中使用和以 node_module 结合 gulp 使用。&lt;/p&gt;
&lt;p&gt;我们可以通过&lt;code class=&quot;language-text&quot;&gt;npm&lt;/code&gt;安装 JSHint。这里需要注意的一些问题，如果我们全局安装 JSHint 他是包含了 CLI 和 JavaScript module 的，如果是本地安装则只包含 JavaScript module。&lt;em&gt;关于 node 中 CLI 和 JavaScript module 分别是怎么用的我后续再填坑，有兴趣的可以自己去了解先。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;因为我这里要测试命令行中使用，所以我们全局安装。然后就可以通过&lt;code class=&quot;language-text&quot;&gt;jshint filename&lt;/code&gt;来对制定的文件进行检查了。
rem 全局安装
npm i jshint -g&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;rem 本地安装
npm i jshint&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;配置&lt;/h4&gt;
&lt;p&gt;前面我们已经知道如何对我们指定的文件进行检查了，但是他检查的规则是什么呢？JSHint 会去解析一个&lt;code class=&quot;language-text&quot;&gt;.jshintrc&lt;/code&gt;文件来确定如何检查，这个文件是个&lt;code class=&quot;language-text&quot;&gt;json&lt;/code&gt;格式的配置文件，我们可以配置一些制定项来定制我们的检查计划。里面具体的配置选项可以上官网上查找。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;json&quot;&gt;&lt;pre class=&quot;language-json&quot;&gt;&lt;code class=&quot;language-json&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;&quot;undef&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要注意的是 JSHint 查找这个&lt;code class=&quot;language-text&quot;&gt;.jshintrc&lt;/code&gt;文件规则，会有多种情况：我们可以在我们命令后加上&lt;code class=&quot;language-text&quot;&gt;--config filename&lt;/code&gt;来执行读取对应配置文件进行检查。另外，我们可以在项目中&lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt;文件的&lt;code class=&quot;language-text&quot;&gt;jshintConfig&lt;/code&gt;来配置我们的&lt;code class=&quot;language-text&quot;&gt;.jshintrc&lt;/code&gt;文件路径。如果上面两种都没有配置的话，则是会按 JShint 默认的规则来查找配置文件：JSHint 会在当前目录查找是否有&lt;code class=&quot;language-text&quot;&gt;.jshintrc&lt;/code&gt;文件，如果没有找到则向文件夹上一层查找，一直到查到&lt;code class=&quot;language-text&quot;&gt;.jshintrc&lt;/code&gt;文件或者根目录为止。如果没有指定&lt;code class=&quot;language-text&quot;&gt;.jshintrc&lt;/code&gt;文件，JSHint 是不会对文件就行检查的。&lt;/p&gt;
&lt;p&gt;除了上面这种将检查项配置在&lt;code class=&quot;language-text&quot;&gt;.jshintrc&lt;/code&gt;文件的方式外，我们还可以直接以注释的形式将我们的检查配置写在我们的文件中。如下，如果我们的文件中有这样的注释，我们对该文件进行检查就会对未定义的变量进行检查。我们在代码文件中增加 jshint 配置并不会终止查找&lt;code class=&quot;language-text&quot;&gt;.jshintrc&lt;/code&gt;文件读取配置的流程，只是如果代码文件中和&lt;code class=&quot;language-text&quot;&gt;.jshintrc&lt;/code&gt;有相同的配置时代码文件中的配置会更高。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* jshint undef: true */&lt;/span&gt;

your code&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们在项目中有些文件来自第三方，这些文件不要求尊求我们的规范，我们就需要将这些文件排除在我们的检查列表之外，这时我们就需要另外一个配置文件&lt;code class=&quot;language-text&quot;&gt;.jshintignore&lt;/code&gt;。这个文件主要用于配置哪些文件不用于 JSHint 的检查，里面可以放具体的文件名或者文件夹名（该目录下都不被检查）。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;node_module
app/test.js&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;gulp-jshint&lt;/h3&gt;
&lt;p&gt;在项目中我们肯定不会用命令挨个检查文件是否符合规范，所以我们通常会配合&lt;code class=&quot;language-text&quot;&gt;gulp&lt;/code&gt;这类自动化工具来做这些重复的事情。由于 gulp 是基于“流”的形式来处理的，所以我们无法直接使用 JSHint，我们需要安转一个&lt;code class=&quot;language-text&quot;&gt;gulp-jshint&lt;/code&gt;，然后就可以在我们的 gulp 任务中加入 JSHint 的检查了。下面我们罗列一个简单的使用 JSHint 检查 app 路径下所有 JS 文件的示例代码。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; gulp &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;gulp&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; JSHint &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;gulp-jshint&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

gulp&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;checkCode&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; gulp
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;./app/**/*.js&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;JSHint&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;JSHint&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;reporter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;default&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JSHint 检查的结果是通过命令行输出的，我们可以使用&lt;code class=&quot;language-text&quot;&gt;.pipe(JSHint.reporter(&apos;default&apos;))&lt;/code&gt;来使用默认的样式输出检查结果，为了增强可读性，我们通常还会使用&lt;code class=&quot;language-text&quot;&gt;jshint-stylish&lt;/code&gt;来对结果进行美化。
&lt;img src=&quot;http://7xqhnl.com1.z0.glb.clouddn.com/jshint%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA.png&quot; alt=&quot;iamge&quot;&gt;&lt;/p&gt;
&lt;p&gt;另外提下在某些情况下我们要检查的 js 代码可能位于其他类型文件内（如 HTML、JSX 等），我们可以通过配置来实现。还有就是自定义一个 reporter 而不是使用 JSHint.reporter。这些都可以通过查找&lt;a href=&quot;https://github.com/spalger/gulp-jshint&quot;&gt;文档&lt;/a&gt;来了解具体的操作步骤。&lt;/p&gt;
&lt;h3&gt;git-hooks&lt;/h3&gt;
&lt;p&gt;以上我们就已经实现了使用 gulp 自动对项目文件进行规范检查，但是我们不想手动的去执行这个 gulp 任务，应该手动的话肯定就有人会偷懒了。所以我们考虑可以把 checkcode 任务集成到编译任务，因为前面都已经用到了 gulp 了，说明我们的项目肯定是会需要构建才能调试的，所以我们可以把 checkCode 任务集成进去。但是这样做有个缺点，我们的构建任务通常会是一个高频任务，但是 checkCode 任务肯定会是一个耗时的任务，而且项目稳定之后 checkCode 检查出的问题应该是很少的，所以这样做我们的时间浪费是不值得的，所以我们就得考虑把 checkCode 集成到一个低频的操作中去。这时就是我们的 git-hooks 登场了。&lt;/p&gt;
&lt;p&gt;通常我们都会使用 svn/git 这类工具对我们的代码进行管理，除了我们常用的那些 pull/push 功能，我们还可以利用他们提供的 hooks 来在特定的操作中加入我们自己的操作，比如我们这里将要用到的&lt;code class=&quot;language-text&quot;&gt;pre-commit&lt;/code&gt;hook 就能在代码 commit 之前执行我们预设的脚本。因为现在比较流行 git，所以我们接下的方案将是基于 git 来做的。&lt;/p&gt;
&lt;p&gt;我们通过&lt;code class=&quot;language-text&quot;&gt;git init&lt;/code&gt;或者&lt;code class=&quot;language-text&quot;&gt;git clone&lt;/code&gt;创建一个 git 项目时，会在项目顶层目录中生成一个&lt;code class=&quot;language-text&quot;&gt;.git&lt;/code&gt;文件夹（隐藏的），里面就包含了我们的一些 git 的配置信息，我们要了解的 hooks 就位于&lt;code class=&quot;language-text&quot;&gt;hooks&lt;/code&gt;目录下。文件夹内放置了很多 hook 的模板，不过这些&lt;code class=&quot;language-text&quot;&gt;.sample&lt;/code&gt;后缀的文件是不能识别的，想让他们执行只要去掉后缀即可。这里的提供的 hooks 只是客户端的 hook，在 server 端也有一些 hook，可以去&lt;a href=&quot;https://git-scm.com/docs/githooks&quot;&gt;这里&lt;/a&gt;查找全部 hook 的信息和用法。示例中的 hook 是用&lt;code class=&quot;language-text&quot;&gt;shell&lt;/code&gt;写的，但是他是支持&lt;code class=&quot;language-text&quot;&gt;Ruby&lt;/code&gt;或者&lt;code class=&quot;language-text&quot;&gt;Python&lt;/code&gt;来写的。
&lt;img src=&quot;http://7xqhnl.com1.z0.glb.clouddn.com/git-hooks.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面我参考以前同事的&lt;code class=&quot;language-text&quot;&gt;pre-commit&lt;/code&gt;的脚本，具体内容不再叙述。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token shebang important&quot;&gt;#!/bin/sh&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;#执行gulp任务，并将结果输出到临时文件&lt;/span&gt;
gulp checkCode &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;tee&lt;/span&gt; check.log

&lt;span class=&quot;token comment&quot;&gt;#检查gulp的check任务是否执行失败&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;warning&quot;&lt;/span&gt; check.log &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;error&quot;&lt;/span&gt; check.log
&lt;span class=&quot;token keyword&quot;&gt;then&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; -e &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token entity&quot; title=&quot;\033&quot;&gt;\033&lt;/span&gt;[31m Code check fail! Please try again! &lt;span class=&quot;token entity&quot; title=&quot;\033&quot;&gt;\033&lt;/span&gt;[0m&quot;&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;exit&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; -e &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token entity&quot; title=&quot;\033&quot;&gt;\033&lt;/span&gt;[32m Code check success! &lt;span class=&quot;token entity&quot; title=&quot;\033&quot;&gt;\033&lt;/span&gt;[0m&quot;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;fi&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;#删除临时文件&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;rm&lt;/span&gt; check.log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此，一套结合 git-hooks、gulp 和 JSHint 的代码检查方案就完成了。这种方案不一样会在你的项目中运用，但是了解其中运用的一些东西能帮助你拓宽下视野，对以后或许有帮助。最后，因本人水平有限，如果上文中出现一些错误，请直接指出，勿喷。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[window下几种以当前路径打开命令行的方式]]></title><description><![CDATA[此技巧仅用于 window 平台，osx 用户绕道。 方法一 最原始的方法，手动调出 cmd，然后通过命令切换到指定目录。 方法二 用资源管理器打开指定目录后，在资源管理器的地址栏里输入 cmd…]]></description><link>https://dingziqi.github.io/doshere-in-window/</link><guid isPermaLink="false">https://dingziqi.github.io/doshere-in-window/</guid><pubDate>Mon, 13 Jun 2016 12:01:05 GMT</pubDate><content:encoded>&lt;p&gt;此技巧仅用于 window 平台，osx 用户绕道。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3&gt;方法一&lt;/h3&gt;
&lt;p&gt;最原始的方法，手动调出 cmd，然后通过&lt;code class=&quot;language-text&quot;&gt;cd&lt;/code&gt;命令切换到指定目录。&lt;/p&gt;
&lt;h3&gt;方法二&lt;/h3&gt;
&lt;p&gt;用资源管理器打开指定目录后，在资源管理器的地址栏里输入 cmd，回车即可。&lt;/p&gt;
&lt;h3&gt;方法三&lt;/h3&gt;
&lt;p&gt;在资源管理内，选中你要定位的文件夹，然后按住&lt;code class=&quot;language-text&quot;&gt;Shift&lt;/code&gt;键点击鼠标右键，你会发现弹出的右键菜单比平时多个&lt;code class=&quot;language-text&quot;&gt;在此处打开命令行窗口&lt;/code&gt;，点击它即可。如果你选中的文件的话，是没有这个按钮的，只有一个&lt;code class=&quot;language-text&quot;&gt;复制为路径&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;方法三&lt;/h3&gt;
&lt;p&gt;在 window 下面我们鼠标右键的菜单是可以定制，只需要修改我们的注册表即可。所以我们经常在装完一些 IDE 后右键菜单多几个&lt;code class=&quot;language-text&quot;&gt;Open with XXX&lt;/code&gt;，我们要可以加一个&lt;code class=&quot;language-text&quot;&gt;Open with DOS&lt;/code&gt;。具体的步骤是：
打开注册表（可以在开始菜单的快速搜索栏输入&lt;code class=&quot;language-text&quot;&gt;regEdit&lt;/code&gt;，然后点击程序栏下的&lt;code class=&quot;language-text&quot;&gt;regEdit.exe&lt;/code&gt;）；&lt;/p&gt;
&lt;p&gt;然后打开注册表的&lt;code class=&quot;language-text&quot;&gt;HKEY_CLASSES_ROOT\Folder\shell&lt;/code&gt;，这个目录下各项就是文件夹右键的命令，每一项（即 shell 内一层目录）的结构都是固定的，内部含有一个&lt;code class=&quot;language-text&quot;&gt;command&lt;/code&gt;项。&lt;/p&gt;
&lt;p&gt;我们要做的就是在 shell 目录下&lt;code class=&quot;language-text&quot;&gt;右键&lt;/code&gt;&gt;&lt;code class=&quot;language-text&quot;&gt;新建&lt;/code&gt;&gt;&lt;code class=&quot;language-text&quot;&gt;项&lt;/code&gt;，项的名称随意取(我取的是&lt;code class=&quot;language-text&quot;&gt;dosHere&lt;/code&gt;)。然后我们就可以在右边这栏双击名称下面的值，然后修改&lt;code class=&quot;language-text&quot;&gt;数据数值&lt;/code&gt;，这个值就是对应的我们右键菜单的新增命令的名称，我取的是&lt;code class=&quot;language-text&quot;&gt;Open with DOS&lt;/code&gt;;&lt;/p&gt;
&lt;p&gt;然后我们在&lt;code class=&quot;language-text&quot;&gt;dosHere&lt;/code&gt;这项内新增名为&lt;code class=&quot;language-text&quot;&gt;command&lt;/code&gt;项，这个名称是固定的。这个&lt;code class=&quot;language-text&quot;&gt;command&lt;/code&gt;的值是我们点击我们新增的右键菜单的执行的 shell 命令，我们把值设为&lt;code class=&quot;language-text&quot;&gt;cmd.exe /k cd %1&lt;/code&gt;，设置方法同上。这个命令大概的功能就是在当前路径下执行&lt;code class=&quot;language-text&quot;&gt;cmd.exe&lt;/code&gt;，然后再执行&lt;code class=&quot;language-text&quot;&gt;cd %1&lt;/code&gt;。这里的&lt;code class=&quot;language-text&quot;&gt;%1&lt;/code&gt;最终会被操作的文件替代。这个命令详细的解释可以取拓展 shell 相关的知识。&lt;/p&gt;</content:encoded></item></channel></rss>